{"meta":{"title":"一丶回","subtitle":"前端打怪记录&诗与远方","description":"前端打怪记录&诗与远方，一些日常学习的心得，或是好的文章分享，工作爬坑记录等，或许还会放一些日常生活(*^__^*) 嘻嘻……","author":"YI HUI","url":"http://yihui37.github.io"},"pages":[{"title":"about","date":"2019-01-13T11:14:52.000Z","updated":"2019-01-13T11:14:52.356Z","comments":true,"path":"about/index.html","permalink":"http://yihui37.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:14:30.146Z","comments":false,"path":"categories/index.html","permalink":"http://yihui37.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:11:52.724Z","comments":false,"path":"tags/index.html","permalink":"http://yihui37.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fullstack lesson1","slug":"Fullstack-lesson1","date":"2019-01-08T14:58:51.000Z","updated":"2019-01-08T15:00:16.210Z","comments":true,"path":"2019/01/08/Fullstack-lesson1/","link":"","permalink":"http://yihui37.github.io/2019/01/08/Fullstack-lesson1/","excerpt":"","text":"VUE-CLI 3与VUE-CLI 2 的区别 npm安装依赖名称变更 @vue/cli CLI2中的cofig文件夹取消，变更为使用在根目录下创建vue.config.js文件来进行配置 CLI3实例化方式有区别，如下： 1234567891011// CLI2new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;)// CLI3new Vue(&#123; render: h =&gt; h(App), // 渲染App组件供$mount挂载&#125;).$mount('#app') // 将render出的App组件挂载到DOM#app上 快速原型开发 运行单个.vue文件 123npm install -g @vue/cli-service-globalcd &lt;filepath&gt;vue serve &lt;filename&gt; 单个.vue文件中 data必须以function形式返回，而在组件形式的.vue文件中，则以对象形式返回 快速创建项目在package.json文件中，配置start和dev/build等，在执行时start不需要加run 1234npm startnpm run devnpm run build... Mock数据 项目根目录下配置vue.config.js文件，创建一个自定义的接口返回 安装axios依赖 注意重启项目 如使用ES7的async await来处理异步，则注意错误处理使用try catch","categories":[{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/categories/Fullstack/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"}]},{"title":"Element-UI 自定义参数传递","slug":"Element-UI组件回调自定义传参","date":"2018-07-26T08:46:26.000Z","updated":"2018-07-26T08:50:37.000Z","comments":true,"path":"2018/07/26/Element-UI组件回调自定义传参/","link":"","permalink":"http://yihui37.github.io/2018/07/26/Element-UI组件回调自定义传参/","excerpt":"","text":"本文主要讲述Element-UI中组件事件回调如何在保留默认传参的情况下，额外传递自定义参数。 Element-UI框架中的组件事件回调传参一般只有v-model的绑定值，然而在实际开发过程中，经常会遇到既需要绑定值，也需要其他参数（尤以循环数组需要当前对象和index居多）的情况。在项目搭建伊始，这个问题就在困扰着我，当时的解决方法尤其笨拙： 在绑定组件上添加click事件，将自定义参数通过click事件绑定到全局变量中，之后通过全局变量来确定当前变更元素。此方法一是需要确保click事件比组件的change事件优先执行；二是新增了变量就意味着占据内存来存储一个既有值；三是一不小心就会忘了当前存储值是什么，需要不断log调试 这个笨拙的方法虽然解决了问题，却有一种问我9✖️9等于多少，我只能用9+9+9+9+9+9+9+9+9=81累加方法算出答案，一直觉得麻烦，却不知道好方法的感觉。 当然，如今我终于习得99乘法表。 使用闭包重新包装回调函数 @change=&quot;selectValue=&gt;handleChange(selectValue,index)&quot;此方法简单高效，直接解决了困扰已久的问题，激动无以言表 实例有一组数据selectedRepos，其中每个元素都需要通过远程搜索获取到可选列表再进行选择，同时将搜索结果作为属性值保存在当前元素中。123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;repoWrap&quot; v-for=&quot;(repo,index) of selectedRepos&quot; :key=&quot;index&quot;&gt; &lt;el-select :ref=&quot;`repoSelect$&#123;index&#125;`&quot; v-model=&quot;repo.id&quot; remote // 远程搜索，既需要查询条件query，也需要当前数组元素repo :remote-method=&quot;query=&gt;remoteSearch(query,repo)&quot; @change=&quot;selectRepo(repo)&quot; :loading=&quot;remote_loading&quot; value-key=&quot;repo_info.id&quot;&gt; &lt;el-option v-for=&quot;repo in repo.repoOptions&quot; :key=&quot;repo.id&quot; :label=&quot;repo.repo_name&quot; :value=&quot;repo&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; remoteSearch(query,repo)&#123; ... &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yihui37.github.io/tags/Javascript/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"}]},{"title":"Element Dialog append-to-body","slug":"el-dialog关闭","date":"2018-07-16T07:13:29.000Z","updated":"2018-07-26T08:47:06.000Z","comments":true,"path":"2018/07/16/el-dialog关闭/","link":"","permalink":"http://yihui37.github.io/2018/07/16/el-dialog关闭/","excerpt":"","text":"Element Dialog 无法关闭 本文主要介绍Element-UI(VUE)·Dialog的append-to-body属性 你是否在使用Dialog的过程中，遇到过不能关闭或Dialog Events无效，却不知道如何解决？ 现在让我们一起来看看append-to-body能不能帮助你解决这个问题吧。 Dialog 官方文档 $ Attributes 在实际开发过程中，虽然在单个组件中只有一个Dialog，但实际页面中，由于父子组件间的多层嵌套，Dialog也具有了嵌套的关系，从而导致内外Dialog的遮罩层级关系出错、无法捕捉关闭事件等一系列问题。因此，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 实例 父组件 1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\"&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; 子组件 serviceDetail 12345methods: &#123; handleDeploy() &#123; commonVue.$emit('openServiceDeploy'); // 打开公共组件 &#125;&#125; 公共组件 rightContainer 123456&lt;!-- 子组件中的Dialog 第二层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"rightContainer-dialog\" :visible.sync=\"visible\"&gt; ... &lt;/el-dialog&gt;&lt;/template&gt; 问题：在上例中，父组件有一个Dialog，其中嵌套了子组件serviceDetail，在serviceDetail组件中，调用了公共方法打开公共组件Dialog。此时，页面上共存两个dialog，但是父组件中的Dialog（页面视觉上在下面一层）无法关闭。解决方法：在父组件的Dialog上添加append-to-body属性，重组层级关系。1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\" append-to-body&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; TIP：在开发过程中，很可能因为子组件中没有直接写Dialog代码，而忽略了公共组件中Dialog的嵌套问题，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 PS：无脑添加append-to-body属性是否会带来性能方面的影响暂未研究。如有此方面研究，请不吝赐教。","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Dialog","slug":"Dialog","permalink":"http://yihui37.github.io/tags/Dialog/"}]},{"title":"Element select value-key","slug":"el-select绑定值为对象类型","date":"2018-07-11T07:13:29.000Z","updated":"2018-07-26T08:47:13.000Z","comments":true,"path":"2018/07/11/el-select绑定值为对象类型/","link":"","permalink":"http://yihui37.github.io/2018/07/11/el-select绑定值为对象类型/","excerpt":"","text":"Element-UI Select 绑定值为Object对象类型 本文主要介绍Element-UI(VUE)·Select的value-key属性 在使用Element1.0的开发过程中，option的value只能绑定字符串或数字，常常在选择之后再实时根据v-model绑定的值进行数据的筛选，从而获取到object中其它需要的属性数据； 现在Select对value新增了object数据类型的支持，我们来看看要怎么使用吧。 Select 官方文档 $ Select Attributes Option Attributes 由此可以看出，当value绑定值类型为object时，value-key为必填项，其值为对象的某个key[字符串类型] 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;el-select v-model=&quot;selectItems&quot; // Array multiple // 多选 value-key=&quot;id&quot; // 指定object的唯一标识（id是item的一个key） @change=&quot;handleChange&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.id&quot; // v-for 的 key :label=&quot;item.title&quot; :value=&quot;item&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; options: [&#123; id:1, value: &apos;选项1&apos;, title: &apos;黄金糕&apos; &#125;, &#123; id:2, value: &apos;选项2&apos;, title: &apos;双皮奶&apos; &#125;, &#123; id:3, value: &apos;选项3&apos;, title: &apos;蚵仔煎&apos; &#125;, &#123; id:4, value: &apos;选项4&apos;, title: &apos;龙须面&apos; &#125;], selectItems: [], &#125; &#125;, methods:&#123; handleChange(selectItems)&#123; console.log(&apos;选中值&apos;,selectItems); // 选中值 [object,object] &#125; &#125; &#125;&lt;/script&gt; TIPS 注意区分select的value-key和option的key 前者作为select的属性，是value值的唯一标识后者是使用v-for时，给每个节点做一个唯一标识，此时key的作用主要是为了高效的更新虚拟DOM","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Select","slug":"Select","permalink":"http://yihui37.github.io/tags/Select/"}]},{"title":"css-border滑动动画","slug":"css-border滑动动画","date":"2018-02-27T07:49:51.000Z","updated":"2018-07-13T07:02:50.000Z","comments":true,"path":"2018/02/27/css-border滑动动画/","link":"","permalink":"http://yihui37.github.io/2018/02/27/css-border滑动动画/","excerpt":"","text":"本文主要使用css-transition属性来实现元素边框的流动动画效果 序无意中发现个人主页插件演示页面，在个人履历中看到了边框滑动效果，研究了一下发现是由纯css完成的，由此记录学习一下。在之前学习svg的过程中，实现过不规则图形的边框滑动效果，由于实现方式比较复杂，所以很少在实际项目中使用。 效果展示移动鼠标到这里查看效果~ 原理分析调试分析后发现实际是使用两个同样大小的内外盒子，使用伪类元素::before ::after来模拟边框。一个盒子负责上下边框，另一个负责左右边框。由起点框开始变化，变化结束后，另一个盒子再承接上一个结束点进行变化，由此在视觉上看起来等同于一个盒子的边框动画。 实现代码12345678&lt;!--html--&gt;&lt;div class=\"border-slide-wrapper\"&gt; &lt;div class=\"outwrap\"&gt; &lt;div class=\"innerwrap\"&gt; &lt;h3&gt;移动鼠标到这里查看效果~&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*stylus*/.border-slide-wrapper text-align center margin 15px .outwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 0px height 2px background #FF9D9B transition .2s all linear // 无延迟 &amp;::before top 0px left 0px &amp;::after bottom 0px right 0px &amp;:hover::before,&amp;:hover::after width 100% .innerwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 2px height 0px background #FF9D9B transition .2s all linear .2s // 延迟.2s，等待前置滑动结束 &amp;::before bottom 0px left 0px &amp;::after top 0px right 0px &amp;:hover::before,&amp;:hover::after height 100% h3 padding 20px color #FF7C79","categories":[{"name":"CSS奇幻世界","slug":"CSS奇幻世界","permalink":"http://yihui37.github.io/categories/CSS奇幻世界/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yihui37.github.io/tags/css/"},{"name":"边框","slug":"边框","permalink":"http://yihui37.github.io/tags/边框/"},{"name":"滑动","slug":"滑动","permalink":"http://yihui37.github.io/tags/滑动/"}]},{"title":"vue.js","slug":"vue-js","date":"2018-01-12T03:53:59.000Z","updated":"2018-07-13T07:02:47.000Z","comments":true,"path":"2018/01/12/vue-js/","link":"","permalink":"http://yihui37.github.io/2018/01/12/vue-js/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Markdown简介","slug":"欢迎使用马克飞象","date":"2018-01-12T03:53:59.000Z","updated":"2018-01-12T10:00:34.000Z","comments":true,"path":"2018/01/12/欢迎使用马克飞象/","link":"","permalink":"http://yihui37.github.io/2018/01/12/欢迎使用马克飞象/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#115;&#116;&#103;&#x6f;&#99;&#x6b;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-12T03:12:55.000Z","updated":"2018-01-12T03:12:55.000Z","comments":true,"path":"2018/01/12/hello-world/","link":"","permalink":"http://yihui37.github.io/2018/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}