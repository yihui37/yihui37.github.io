{"meta":{"title":"一丶回","subtitle":"前端打怪记录&诗与远方","description":"前端打怪记录&诗与远方，一些日常学习的心得，或是好的文章分享，工作爬坑记录等，或许还会放一些日常生活(*^__^*) 嘻嘻……","author":"YI HUI","url":"http://yihui37.github.io"},"pages":[{"title":"categories","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:14:30.146Z","comments":false,"path":"categories/index.html","permalink":"http://yihui37.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-01-13T11:14:52.000Z","updated":"2019-01-13T11:14:52.356Z","comments":true,"path":"about/index.html","permalink":"http://yihui37.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:11:52.724Z","comments":false,"path":"tags/index.html","permalink":"http://yihui37.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Fullstack lesson2","slug":"Fullstack-lesson2","date":"2019-01-13T12:10:07.000Z","updated":"2019-01-13T12:11:44.259Z","comments":true,"path":"2019/01/13/Fullstack-lesson2/","link":"","permalink":"http://yihui37.github.io/2019/01/13/Fullstack-lesson2/","excerpt":"","text":"本文为自己学习笔记，而不是一篇教程，仅供自己日后回顾使用但若其中某tip能为你提供些许帮助，你可以在心里为我撒个花花🌹(^__^) 自己写一个el-form参照element-ui自己尝试模拟写了一个el-form的公共组件，实现登录验证功能： input失去焦点时进行单个验证 点击登录按钮时整体表单验证 验证使用async-validate插件完成 组件层级本次登录组件主要由三个组件组成 Form - 最外层表单 FormItem - 表单项 Input - 表单数据输入，可以由不同其他DOM代替三者关系如图TODO 图Slot组件间由slot插槽进行相互关联，因此不可用@event来绑定监听事件，即插槽内的子组件不可用直接用$emit来触发父组件事件。解决方式 this.$parent.$emit存在问题：如果用户不按照既定层级编写组件，则会存在this.$parent不是我们要找的FormItem的问题 commonVue绑定（不推荐）需要自己实例化一个外部VUE，并引入，并且事件的绑定和触发来源会难以追溯Provide&amp;Inject 官方说明注意：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。我们在Form层级将表单父级使用provide抛出，在FormItem层级通过Inject将父级依赖注入，这样不论FormItem是多少层级的组件，都可以直接获得最外父级的属性和方法。 1234567891011121314&#123;name: \"my-form\", provide() &#123; return &#123; // 将表单实例传递给后代 form: this &#125;; &#125;&#125;&#123; name: \"my-form-item\", inject: [\"form\"], // 注入form，获取model和rules&#125; 这样，在FormItem进行验证的时候，就可以使用用户绑定在Form中的验证项和验证规则 Input的事件作为表单输入框，input主要承担数据的输入工作，一方面它接受父组件传入的参数作为默认值，另一方面在用户改变输入值的同时触发校验 单向数据流 根据VUE的单向数据流规则，从props获取到的数据，子组件是不允许修改的，因此input在用户改变输入之后的处理回调里，需要通知父组件进行数据更新 触发校验 input的校验通常有@blur和@input两种，可以在组件上新增一个trigger属性，用户就可以自己选择触发方式 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;input :type=\"type\" :value=\"inputValue\" @blur=\"validate\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"my-input\", props: &#123; value: &#123; type: String, default: \"\" &#125;, type: &#123; type: String, default: \"text\" &#125; &#125;, data() &#123; return &#123; inputValue: this.value // 单向数据流,接受父组件传过来的默认值 &#125;; &#125;, methods: &#123; validate(e) &#123; this.inputValue = e.target.value; // 必要，通知父组件更新 this.$emit(\"input\", this.inputValue); // 通知父组件校验 // tip: 不自己校验是因为 // form整体校验的时候，并不一定就是input，还可能会是复杂组件 // 因此在formitem层级进行校验 // 方法一：错误 // this.$emit(\"validate\", this.inputValue); // 因为input以插槽的形式插入formitem中，并不能直接$emit // 方法二：当用户不按既定层级编写代码时，$parent不是formitem,因此不完善 this.$parent.$emit(\"validate\", this.inputValue); &#125; &#125;&#125;; Async-validate单个表单的校验async-validate12345678910111213141516171819202122232425262728293031// 验证单个formitem validate() &#123; // promise作用为 在整体校验时提供状态 return new Promise(res =&gt; &#123; // 校验规则 const descriptor = &#123; // 此处this.form为父组件provider提供 [this.prop]: this.form.rules[this.prop] &#125;; const validator = new schema(descriptor); // 执行校验 // 校验参数 param // &#123; prop : propValue&#125; propValue由父组件的provider this.form.model[this.prop] &#125;); validator.validate( &#123; [this.prop]: this.form.model[this.prop] &#125;, errors =&gt; &#123; if (errors) &#123; this.isError = true; this.errormsg = errors[0].message; res(false); &#125; else &#123; this.isError = false; this.errormsg = \"\"; res(true); &#125; &#125; ); &#125;); &#125; TIPS: 别忘了引入async-validate Validate以promise返回，供表单整体校验时提供异步等待机制整体校验 缓存需要校验的表单项，有些没有prop的不需要校验 使用async await和Promise.all进行整体校验判断1234567891011121314151617&#123; created() &#123; // 缓存需要校验的表单项 this.fields = []; this.$on(\"formItemAdd\", item =&gt; this.fields.push(item)); &#125;, methods: &#123; // 回调 // 验证所有formitem async validate(callback) &#123; const tasks = this.fields.map(item =&gt; item.validate()); const results = await Promise.all(tasks); let flag = results.filter(valid =&gt; valid == false).length == 0; callback(flag); &#125; &#125;&#125; 自定义组件命名注意：自定义组件name属性不要和已安装的UI组件的标签名称一致，渲染时会报堆栈溢出，找了半天bug😭。123export default &#123; name: “el-form” // 不要取element-ui一样的名称 &#125;","categories":[{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/categories/Fullstack/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/tags/Fullstack/"}]},{"title":"Fullstack lesson1","slug":"Fullstack-lesson1","date":"2019-01-08T14:58:51.000Z","updated":"2019-01-13T12:12:01.270Z","comments":true,"path":"2019/01/08/Fullstack-lesson1/","link":"","permalink":"http://yihui37.github.io/2019/01/08/Fullstack-lesson1/","excerpt":"","text":"本文为自己学习笔记，而不是一篇教程，仅供自己日后回顾使用但若其中某tip能为你提供些许帮助，你可以在心里为我撒个花花🌹(^__^) VUE-CLI 3与VUE-CLI 2 的区别 npm安装依赖名称变更 @vue/cli CLI2中的cofig文件夹取消，变更为使用在根目录下创建vue.config.js文件来进行配置 CLI3实例化方式有区别，如下： 1234567891011// CLI2new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;)// CLI3new Vue(&#123; render: h =&gt; h(App), // 渲染App组件供$mount挂载&#125;).$mount('#app') // 将render出的App组件挂载到DOM#app上 快速原型开发 运行单个.vue文件 123npm install -g @vue/cli-service-globalcd &lt;filepath&gt;vue serve &lt;filename&gt; 单个.vue文件中 data必须以function形式返回，而在组件形式的.vue文件中，则以对象形式返回 快速创建项目在package.json文件中，配置start和dev/build等，在执行时start不需要加run 1234npm startnpm run devnpm run build... Mock数据 项目根目录下配置vue.config.js文件，创建一个自定义的接口返回 安装axios依赖 注意重启项目 如使用ES7的async await来处理异步，则注意错误处理使用try catch","categories":[{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/categories/Fullstack/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/tags/Fullstack/"}]},{"title":"Element-UI 自定义参数传递","slug":"Element-UI组件回调自定义传参","date":"2018-07-26T08:46:26.000Z","updated":"2019-01-13T12:12:22.143Z","comments":true,"path":"2018/07/26/Element-UI组件回调自定义传参/","link":"","permalink":"http://yihui37.github.io/2018/07/26/Element-UI组件回调自定义传参/","excerpt":"","text":"本文主要讲述Element-UI中组件事件回调如何在保留默认传参的情况下，额外传递自定义参数。 Element-UI框架中的组件事件回调传参一般只有v-model的绑定值，然而在实际开发过程中，经常会遇到既需要绑定值，也需要其他参数（尤以循环数组需要当前对象和index居多）的情况。在项目搭建伊始，这个问题就在困扰着我，当时的解决方法尤其笨拙： 在绑定组件上添加click事件，将自定义参数通过click事件绑定到全局变量中，之后通过全局变量来确定当前变更元素。此方法一是需要确保click事件比组件的change事件优先执行；二是新增了变量就意味着占据内存来存储一个既有值；三是一不小心就会忘了当前存储值是什么，需要不断log调试 这个笨拙的方法虽然解决了问题，却有一种问我9✖️9等于多少，我只能用9+9+9+9+9+9+9+9+9=81累加方法算出答案，一直觉得麻烦，却不知道好方法的感觉。 当然，如今我终于习得99乘法表。 使用闭包重新包装回调函数 @change=&quot;selectValue=&gt;handleChange(selectValue,index)&quot;此方法简单高效，直接解决了困扰已久的问题，激动无以言表 实例有一组数据selectedRepos，其中每个元素都需要通过远程搜索获取到可选列表再进行选择，同时将搜索结果作为属性值保存在当前元素中。123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;repoWrap&quot; v-for=&quot;(repo,index) of selectedRepos&quot; :key=&quot;index&quot;&gt; &lt;el-select :ref=&quot;`repoSelect$&#123;index&#125;`&quot; v-model=&quot;repo.id&quot; remote // 远程搜索，既需要查询条件query，也需要当前数组元素repo :remote-method=&quot;query=&gt;remoteSearch(query,repo)&quot; @change=&quot;selectRepo(repo)&quot; :loading=&quot;remote_loading&quot; value-key=&quot;repo_info.id&quot;&gt; &lt;el-option v-for=&quot;repo in repo.repoOptions&quot; :key=&quot;repo.id&quot; :label=&quot;repo.repo_name&quot; :value=&quot;repo&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; remoteSearch(query,repo)&#123; ... &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yihui37.github.io/tags/Javascript/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"}]},{"title":"Element Dialog append-to-body","slug":"el-dialog关闭","date":"2018-07-16T07:13:29.000Z","updated":"2018-07-26T08:47:06.000Z","comments":true,"path":"2018/07/16/el-dialog关闭/","link":"","permalink":"http://yihui37.github.io/2018/07/16/el-dialog关闭/","excerpt":"","text":"Element Dialog 无法关闭 本文主要介绍Element-UI(VUE)·Dialog的append-to-body属性 你是否在使用Dialog的过程中，遇到过不能关闭或Dialog Events无效，却不知道如何解决？ 现在让我们一起来看看append-to-body能不能帮助你解决这个问题吧。 Dialog 官方文档 $ Attributes 在实际开发过程中，虽然在单个组件中只有一个Dialog，但实际页面中，由于父子组件间的多层嵌套，Dialog也具有了嵌套的关系，从而导致内外Dialog的遮罩层级关系出错、无法捕捉关闭事件等一系列问题。因此，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 实例 父组件 1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\"&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; 子组件 serviceDetail 12345methods: &#123; handleDeploy() &#123; commonVue.$emit('openServiceDeploy'); // 打开公共组件 &#125;&#125; 公共组件 rightContainer 123456&lt;!-- 子组件中的Dialog 第二层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"rightContainer-dialog\" :visible.sync=\"visible\"&gt; ... &lt;/el-dialog&gt;&lt;/template&gt; 问题：在上例中，父组件有一个Dialog，其中嵌套了子组件serviceDetail，在serviceDetail组件中，调用了公共方法打开公共组件Dialog。此时，页面上共存两个dialog，但是父组件中的Dialog（页面视觉上在下面一层）无法关闭。解决方法：在父组件的Dialog上添加append-to-body属性，重组层级关系。1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\" append-to-body&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; TIP：在开发过程中，很可能因为子组件中没有直接写Dialog代码，而忽略了公共组件中Dialog的嵌套问题，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 PS：无脑添加append-to-body属性是否会带来性能方面的影响暂未研究。如有此方面研究，请不吝赐教。","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Dialog","slug":"Dialog","permalink":"http://yihui37.github.io/tags/Dialog/"}]},{"title":"Element select value-key","slug":"el-select绑定值为对象类型","date":"2018-07-11T07:13:29.000Z","updated":"2018-07-26T08:47:13.000Z","comments":true,"path":"2018/07/11/el-select绑定值为对象类型/","link":"","permalink":"http://yihui37.github.io/2018/07/11/el-select绑定值为对象类型/","excerpt":"","text":"Element-UI Select 绑定值为Object对象类型 本文主要介绍Element-UI(VUE)·Select的value-key属性 在使用Element1.0的开发过程中，option的value只能绑定字符串或数字，常常在选择之后再实时根据v-model绑定的值进行数据的筛选，从而获取到object中其它需要的属性数据； 现在Select对value新增了object数据类型的支持，我们来看看要怎么使用吧。 Select 官方文档 $ Select Attributes Option Attributes 由此可以看出，当value绑定值类型为object时，value-key为必填项，其值为对象的某个key[字符串类型] 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;el-select v-model=&quot;selectItems&quot; // Array multiple // 多选 value-key=&quot;id&quot; // 指定object的唯一标识（id是item的一个key） @change=&quot;handleChange&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.id&quot; // v-for 的 key :label=&quot;item.title&quot; :value=&quot;item&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; options: [&#123; id:1, value: &apos;选项1&apos;, title: &apos;黄金糕&apos; &#125;, &#123; id:2, value: &apos;选项2&apos;, title: &apos;双皮奶&apos; &#125;, &#123; id:3, value: &apos;选项3&apos;, title: &apos;蚵仔煎&apos; &#125;, &#123; id:4, value: &apos;选项4&apos;, title: &apos;龙须面&apos; &#125;], selectItems: [], &#125; &#125;, methods:&#123; handleChange(selectItems)&#123; console.log(&apos;选中值&apos;,selectItems); // 选中值 [object,object] &#125; &#125; &#125;&lt;/script&gt; TIPS 注意区分select的value-key和option的key 前者作为select的属性，是value值的唯一标识后者是使用v-for时，给每个节点做一个唯一标识，此时key的作用主要是为了高效的更新虚拟DOM","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Select","slug":"Select","permalink":"http://yihui37.github.io/tags/Select/"}]},{"title":"css-border滑动动画","slug":"css-border滑动动画","date":"2018-02-27T07:49:51.000Z","updated":"2019-01-13T12:13:35.079Z","comments":true,"path":"2018/02/27/css-border滑动动画/","link":"","permalink":"http://yihui37.github.io/2018/02/27/css-border滑动动画/","excerpt":"","text":"本文主要使用css-transition属性来实现元素边框的流动动画效果 序无意中发现个人主页插件演示页面，在个人履历中看到了边框滑动效果，研究了一下发现是由纯css完成的，由此记录学习一下。在之前学习svg的过程中，实现过不规则图形的边框滑动效果，由于实现方式比较复杂，所以很少在实际项目中使用。 效果展示移动鼠标到这里查看效果~ 原理分析调试分析后发现实际是使用两个同样大小的内外盒子，使用伪类元素::before ::after来模拟边框。一个盒子负责上下边框，另一个负责左右边框。由起点框开始变化，变化结束后，另一个盒子再承接上一个结束点进行变化，由此在视觉上看起来等同于一个盒子的边框动画。 实现代码12345678&lt;!--html--&gt;&lt;div class=\"border-slide-wrapper\"&gt; &lt;div class=\"outwrap\"&gt; &lt;div class=\"innerwrap\"&gt; &lt;h3&gt;移动鼠标到这里查看效果~&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*stylus*/.border-slide-wrapper text-align center margin 15px .outwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 0px height 2px background #FF9D9B transition .2s all linear // 无延迟 &amp;::before top 0px left 0px &amp;::after bottom 0px right 0px &amp;:hover::before,&amp;:hover::after width 100% .innerwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 2px height 0px background #FF9D9B transition .2s all linear .2s // 延迟.2s，等待前置滑动结束 &amp;::before bottom 0px left 0px &amp;::after top 0px right 0px &amp;:hover::before,&amp;:hover::after height 100% h3 padding 20px color #FF7C79","categories":[{"name":"CSS奇幻世界","slug":"CSS奇幻世界","permalink":"http://yihui37.github.io/categories/CSS奇幻世界/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yihui37.github.io/tags/CSS/"}]},{"title":"Markdown简介","slug":"欢迎使用马克飞象","date":"2018-01-12T03:53:59.000Z","updated":"2019-01-13T12:13:10.817Z","comments":true,"path":"2018/01/12/欢迎使用马克飞象/","link":"","permalink":"http://yihui37.github.io/2018/01/12/欢迎使用马克飞象/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#115;&#116;&#103;&#111;&#99;&#107;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yihui37.github.io/tags/Markdown/"}]}]}