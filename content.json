{"meta":{"title":"一丶回","subtitle":"前端打怪记录&诗与远方","description":"前端打怪记录&诗与远方，一些日常学习的心得，或是好的文章分享，工作爬坑记录等，或许还会放一些日常生活(*^__^*) 嘻嘻……","author":"YI HUI","url":"http://yihui37.github.io"},"pages":[{"title":"about","date":"2019-01-13T11:14:52.000Z","updated":"2019-01-13T11:14:52.356Z","comments":true,"path":"about/index.html","permalink":"http://yihui37.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:14:30.146Z","comments":false,"path":"categories/index.html","permalink":"http://yihui37.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-13T07:49:03.000Z","updated":"2019-01-13T11:11:52.724Z","comments":false,"path":"tags/index.html","permalink":"http://yihui37.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Convert Sorted List to Binary Search Tree","slug":"Convert-Sorted-List-to-Binary-Search-Tree","date":"2019-02-26T06:33:54.000Z","updated":"2019-02-26T15:11:22.669Z","comments":true,"path":"2019/02/26/Convert-Sorted-List-to-Binary-Search-Tree/","link":"","permalink":"http://yihui37.github.io/2019/02/26/Convert-Sorted-List-to-Binary-Search-Tree/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees ofeverynode never differ by more than 1. Example:Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:12345 0 / \\ -3 9 / /-10 5 解法解法一 不知哪里有问题我的第一次解题思路：依次遍历链表中的node填充到二叉树中。 具体如下：1234567891011121314151617181920submit(head) &#123; if(head==null) return null; let root = new TreeNode(head.val); let curLevelTreeNode = [root]; while(head!==null)&#123; let nodeTmp = []; for(let node of curLevelTreeNode)&#123; head = head.next; if(head==null) break; node.left = new TreeNode(head.val); nodeTmp.push(node.left); head = head.next; if(head==null) break; node.right = new TreeNode(head.val); nodeTmp.push(node.right); &#125; curLevelTreeNode = nodeTmp; &#125; return root;&#125;; 提交后显示为错误答案:[image:7E2FB74D-5CFA-4A1A-8BA8-35A90981E38A-40519-000410855E61CF30/006tKfTcgy1g0juo8b0nqj30ia09mt9b.jpg]但是在题目 110. Balanced Binary Tree验证一个二叉树是否为高度平衡二叉树中，将我的输出结果拿去验证，却是验证成功[image:934DA9E1-A818-48C5-B90C-2A0C82DE4871-40519-000410855E1E5C04/006tKfTcgy1g0jum0sdpkj30cy0a4t91.jpg]即是一个符合条件的高度平衡二叉树，不知哪里出了问题，无法通过，如有知道的，还请不吝赐教。 解法二 76ms为保证创建一个height-balanced的二叉树，首先将链表转化为一个数组，然后取数组中间值作为根节点，再将数组从中间分为左右两个数组，作为根的左右子节点，再以同样方式建立各个叶子节点。 具体如下：12345678910111213141516171819202122submit(head) &#123; if(head==null) return null; // 转为数组 let arr = []; while(head!=null)&#123; arr.push(head.val); head = head.next; &#125; // 将数组转化为二叉树 return buildTree(arr,0,arr.length - 1);&#125;;var buildTree = function (nums,left,right)&#123; if(left &gt; right) return null; if(left == right) return new TreeNode(nums[left]); let mid = parseInt((left + right) / 2), root = new TreeNode(nums[mid]); root.left = buildTree(nums,left,mid-1); root.right = buildTree(nums,mid + 1,right); return root;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"LeetCode/medium","slug":"LeetCode-medium","permalink":"http://yihui37.github.io/tags/LeetCode-medium/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yihui37.github.io/tags/Linked-List/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://yihui37.github.io/tags/Depth-first-Search/"}]},{"title":"Binary Tree Level Order Traversal II","slug":"Binary-Tree-Level-Order-Traversal-II","date":"2019-02-22T07:57:31.000Z","updated":"2019-02-26T15:11:46.496Z","comments":true,"path":"2019/02/22/Binary-Tree-Level-Order-Traversal-II/","link":"","permalink":"http://yihui37.github.io/2019/02/22/Binary-Tree-Level-Order-Traversal-II/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionGiven a binary tree, return thebottom-up level ordertraversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).For example:Given binary tree[3,9,20,null,null,15,7],12345 3 / \\9 20 / \\ 15 7 return its bottom-up level order traversal as:12345[ [15,7], [9,20], [3]] 解法解法一 72ms我的第一次解题思路：从TreeNode的根root开始将每层node暂存到一个堆栈中，遍历堆栈中的每个node，将node值添加到层结果数组中，将node的左右非null子节点存储到层node数组中，将层结果数组存放到最终结果的开头，将层node数组替换堆栈，进行下一次堆栈遍历。 具体如下：1234567891011121314151617submit(root) &#123; if(root==null) return []; let stack = [root], res = []; while(stack.length&gt;0)&#123; let tmp = [], res_each = []; for(let node of stack)&#123; res_each.push(node.val); node.left !== null &amp;&amp; tmp.push(node.left); node.right !== null &amp;&amp; tmp.push(node.right); &#125; stack = tmp; res.unshift(res_each); &#125; return res;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Tree","slug":"Tree","permalink":"http://yihui37.github.io/tags/Tree/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","permalink":"http://yihui37.github.io/tags/Breadth-first-Search/"}]},{"title":"Symmetric Tree","slug":"Symmetric-Tree","date":"2019-02-20T03:42:37.000Z","updated":"2019-02-26T14:57:07.164Z","comments":true,"path":"2019/02/20/Symmetric-Tree/","link":"","permalink":"http://yihui37.github.io/2019/02/20/Symmetric-Tree/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行对称二叉树 - LeetCode 阅读 QuestionGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree[1,2,2,3,4,4,3]is symmetric: 1 / \\ 2 2 / \\ / \\3 4 4 3 But the following[1,2,2,null,3,null,3]is not: 1 / \\ 2 2 \\ \\ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. 解法解法一 80ms我的第一次解题思路：在第100题的经验提示下，将root二叉树copy一份作为镜像，依次对两个二叉树的镜面位置Node进行比较。 具体如下： 123456789101112submit(root) &#123; let judge = (left, right) =&gt; &#123; if (left == null &amp;&amp; right == null) return true; if (left == null || right == null) return false; return ( left.val == right.val &amp;&amp; judge(left.left, right.right) &amp;&amp; judge(left.right, right.left) ); &#125;; return judge(root, root);&#125;; 解法二 84ms题干中说，如果可以用递归和迭代两种方法来解题会是个加分项，因此思考了一下迭代的方式。在之前LinkedList类型题目的提示下想到：仍然将root二叉树copy一份作为镜像，然后新建一个数组，依次将两个二叉树中的镜像位置的Node存放至数组中，则数组中的连续两个元素（镜像对应Node）值应当相等，由此进行判断。 具体如下： 1234567891011121314151617submit(root) &#123; let queue = new Array(); queue.push(root); queue.push(root); while(queue.length)&#123; let t1 = queue.shift(), t2 = queue.shift(); if(t1 == null &amp;&amp; t2 == null) continue; if(t1 == null || t2 == null) return false; if(t1.val !== t2.val) return false; queue.push(t1.left); queue.push(t2.right); queue.push(t1.right); queue.push(t2.left); &#125; return true;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Tree","slug":"Tree","permalink":"http://yihui37.github.io/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://yihui37.github.io/tags/Depth-first-Search/"}]},{"title":"Climbing Stairs","slug":"Climbing-Stairs","date":"2019-02-19T06:27:50.000Z","updated":"2019-02-26T14:55:21.571Z","comments":true,"path":"2019/02/19/Climbing-Stairs/","link":"","permalink":"http://yihui37.github.io/2019/02/19/Climbing-Stairs/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionYou are climbing a stair case. It takesnsteps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Note:Givennwill be a positive integer. Example 1:12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2:123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解法解法一 92ms我的第一次解题思路：一开始觉得题目很熟悉，但是似懂非懂的完全没有头绪，后来看了提示是动态规划类的题目，知道是要根据记住以往的结果来推算演进，但是还是没有想到具体的解决思路。后来在网上的解答中，看到了本题的关键点：到达台阶i的最后一步，只存在两种方法——从i-1台阶迈一步，或者从i-2台阶迈两步，茅塞顿开，想到了具体的解决方法，如下： 具体如下： 12345678910111213submit(n) &#123; if (n &lt;= 1) return 1; let one_forward = 1, two_forward = 1, res = 0; for (let i = 2; i &lt;= n; i++) &#123; // res(i) = res(i-1) + res(i-2); res = one_forward + two_forward; // res(i) two_forward = one_forward; // res(i-2) one_forward = res; // res(i-1) &#125; return res;&#125;; 此题依然是动态规划的相关题目，在题目提示中也提及了斐波那契数列——前两项之和等于后一项。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://yihui37.github.io/tags/Dynamic-Programming/"}]},{"title":"Sqrt(x)","slug":"Sqrt-x","date":"2019-02-16T06:45:36.000Z","updated":"2019-02-16T06:46:25.993Z","comments":true,"path":"2019/02/16/Sqrt-x/","link":"","permalink":"http://yihui37.github.io/2019/02/16/Sqrt-x/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionImplement int sqrt(int x). Compute and return the square root ofx, wherexis guaranteed to be a non-negative integer. Since the return typeis an integer, the decimal digits are truncated and only the integer part of the resultis returned. Example 1:12Input: 4Output: 2 Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 解法解法一 92ms我的第一次解题思路：第一反应是直接使用JS中sqrt方法，然后发现题意是自己实现这种方法，尴尬=-=。看了题干下的提示想到了使用::二分法::，逐渐逼近的方式。由于x的二次方根不会超过它的一般值，因此可以 在[0, n/2+1]这个范围内进行二分搜索，求出n的平方根。注意：最后结果right-1 具体如下： 123456789101112131415submit(x) &#123; if (x &lt;= 1) return x; let left = 0, right =parseInt(x/2+1); while(left &lt; right)&#123; let mid = parseInt((left+right) / 2), num = mid * mid; if (num &gt; x) &#123; right = mid; &#125;else&#123; left = mid + 1; &#125; &#125; return right -1;&#125;; 解法二 96ms 在网上看到了另一个解法，采用的是牛顿迭代法。具体如下：1234567891011submit(x) &#123; if (x == 0) return 0; let last = 0, res = 1; while (res != last) &#123; last = res; res = (res + x / res) / 2; &#125; return parseInt(res); &#125;; [image:3006DAB0-693B-438C-8A18-15D978E353D7-6743-0000B3A864B5E544/7DCF4043-F4BE-4BA5-BA8E-384055D705FD.png]CR：Annie Kim’s Blog","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Math","slug":"Math","permalink":"http://yihui37.github.io/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://yihui37.github.io/tags/Binary-Search/"}]},{"title":"Add Binary","slug":"Add-Binary","date":"2019-02-15T06:43:53.000Z","updated":"2019-02-16T06:45:03.611Z","comments":true,"path":"2019/02/15/Add-Binary/","link":"","permalink":"http://yihui37.github.io/2019/02/15/Add-Binary/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionGiven two binary strings, return their sum (also a binary string). The input strings are bothnon-emptyand contains only characters1or0. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1:12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2:12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; 解法解法一 88ms我的第一次解题思路：取a、b中长度较大值作为遍历次数，一次从后到前将每个元素值相加，与2比较大小，满2进1，余数作为当前指针对应元素存入结果集。具体如下： 12345678910111213141516submit(a,b) &#123; let aArr = a.split(\"\").map(char=&gt;Number(char)), bArr = b.split(\"\").map(char=&gt;Number(char)), aLen = aArr.length, bLen = bArr.length, maxLen = Math.max(aLen,bLen), num = 0, res = []; for(let i = 0;i&lt;maxLen;i++)&#123; let sum = (aArr[aLen -1 - i] || 0) + (bArr[bLen -1 - i] || 0) + num; res[maxLen - 1 - i] = sum &gt; 1 ? sum%2 : sum; num = sum &gt; 1 ? Math.floor(sum/2) : 0; if(i == maxLen - 1 &amp;&amp; num &gt; 0) res.unshift(num); &#125; return res.join('');&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"String","slug":"String","permalink":"http://yihui37.github.io/tags/String/"},{"name":"Math","slug":"Math","permalink":"http://yihui37.github.io/tags/Math/"}]},{"title":"Plus One","slug":"Plus-One","date":"2019-02-12T08:01:43.000Z","updated":"2019-02-16T06:42:30.665Z","comments":true,"path":"2019/02/12/Plus-One/","link":"","permalink":"http://yihui37.github.io/2019/02/12/Plus-One/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionGiven anon-emptyarray of digitsrepresenting a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1:123Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. Example 2:123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 解法解法一 Error 未考虑到数值的有效范围，超出后不可使用数学加法完成我的第一次解题思路：arr.join -&gt; string -&gt; number+1 -&gt; string -&gt; split -&gt; arr[nums]。具体如下： 1234submit(digits) &#123; var num = parseInt(digits.join('')) + 1; return num.toString().split('').map(char=&gt;Number(char));&#125;; 解法二 72ms从数组最后一个元素开始+1，如果和为10，则对前一个元素继续加1，否则结束循环。注意第一位数结果进1，使用unshift向数组开头添加1。 12345678910111213141516submit(digits) &#123; for(let i = digits.length - 1;i&gt;-1;i--)&#123; let num = digits[i] + 1; if(num == 10) &#123; digits[i] = 0; if(i==0)&#123; // 第一位满10进1，多一位 digits.unshift(1); &#125; &#125;else&#123; digits[i] = num; break; &#125; &#125; return digits;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Math","slug":"Math","permalink":"http://yihui37.github.io/tags/Math/"},{"name":"Array","slug":"Array","permalink":"http://yihui37.github.io/tags/Array/"}]},{"title":"Maximum Subarray","slug":"Maximum-Subarray","date":"2019-01-28T08:16:33.000Z","updated":"2019-02-16T06:43:08.325Z","comments":true,"path":"2019/01/28/Maximum-Subarray/","link":"","permalink":"http://yihui37.github.io/2019/01/28/Maximum-Subarray/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example 1:123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解法解法一 Time Limit Exceeded我的第一次解题思路：第一反应就是从前到后循环遍历所有可能性组合，从所有结果中取最大值，但是提交的时候提示我Time Limit Exceeded了。这个费时费力的笨方法直接证明了学算法的重要性/(ㄒoㄒ)/~~。具体如下：12345678910111213141516171819202122var maxSubArray = function(nums) &#123; let len = nums.length,sum = nums[0]; const getMaxSum = (arr)=&gt;&#123; let len = arr.length, sum = arr[0]; for(let i = 1;i&lt;=len;i++)&#123; let tsum = 0; for(let j = 0;j&lt;i;j++)&#123; tsum += arr[j]; &#125; if(sum&lt;tsum) sum = tsum; &#125; return sum; &#125;; for(let i = 0;i&lt;len;i++)&#123; let arr = nums.slice(i), tsum = getMaxSum(arr); if(sum &lt; tsum) sum = tsum; &#125; return sum;&#125;; 解法二 80ms 动态规划看提示有Dynamic Programming动态规划，因此想到在遍历过程中，可以把问题看成是求每一个从0到i的数组中最大的子序列数组和，如果前一次遍历最大和为负数，相当于做减法，因此直接返回当前元素，否则相加。具体如下： 123456789101112var maxSubArray = function(nums) &#123; let res = nums[0], sum = 0; for (let num of nums) &#123; if (sum &gt; 0) sum += num; else sum = num; res = Math.max(res, sum); &#125; return res;&#125;; 解法三 76ms 动态规划优化搜索了一下动态规划，总结解法二有如下递归公式：dp_n = dp_n-1 &gt; 0 ? dp_n-1 + array[n] : array[n]。具体如下： 123456789var maxSubArray = function(nums) &#123; let max = nums[0], dp_n = nums[0]; for(let i=1; i&lt;nums.length; i++)&#123; dp_n = nums[i] + (dp_n&gt;0 ? dp_n : 0); max = dp_n&gt;max ? dp_n : max; &#125; return max;&#125;; 解法四 分治算法题干说明还可以使用Divide and Conquer分治算法来解决，由于对此不了解，因此直接百度了答案，才知道原来二分法也是分治算法的一种。 分治算法_百度百科分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。 用这种方法来解这道题可以用递归的方法，网上有很多帖子来解释，这里贴一个比较全面的LeetCode 53. Maximum Subarray - 简书，可以参考。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://yihui37.github.io/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"http://yihui37.github.io/tags/Array/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://yihui37.github.io/tags/Divide-and-Conquer/"}]},{"title":"Count and Say","slug":"Count-and-Say","date":"2019-01-24T08:33:54.000Z","updated":"2019-02-16T06:40:05.519Z","comments":true,"path":"2019/01/24/Count-and-Say/","link":"","permalink":"http://yihui37.github.io/2019/01/24/Count-and-Say/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionThe count-and-say sequence is the sequence of integers with the first five terms as following: - 1. 1 - 2. 11 - 3. 21 - 4. 1211 - 5. 111221 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the n^th term of the count-and-say sequence. Note Each term of the sequence of integers will be represented as a string. Example 1:12Input: 1Output: &quot;1&quot; Example 2:12Input: 4Output: &quot;1211&quot; 解法解法一 72ms我的第一次解题思路：一开始连题目都没看懂，后来借助了题目的提示1，才看懂了题目的意思：用连续重复数字的个数和值组成下一个数，例如’111221’读为’3个1，2个2，1个1’，因此下一个数为’312211’。 由此的思路为，根据传入值，从第一个‘1’开始循环求下一个数，写一个公共的求下一个数的方法，把上一个数作为参数传入即可。公共方法中，循环当前字符串中每一个字符，记录联系相同字符的个数个值并记录拼接返回。具体如下：12345678910111213141516171819202122232425let getNext = function(str) &#123; let strArr = str.split(\"\").map(char =&gt; Number(char)), count = 0, curVal = strArr[0], res = \"\"; for (let i = 0; i &lt; strArr.length; i++) &#123; if (curVal == strArr[i]) &#123; count++; &#125; else &#123; res += String(count)+String(curVal); count = 1; curVal = strArr[i]; &#125; &#125; res += String(count)+String(curVal); return res;&#125;;submit(n) &#123; let result = \"1\"; for (let j = 1; j &lt; n; j++) &#123; result = getNext(result); &#125; return result;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"String","slug":"String","permalink":"http://yihui37.github.io/tags/String/"}]},{"title":"Remove Element","slug":"Remove-Element","date":"2019-01-24T03:36:11.000Z","updated":"2019-02-16T06:38:29.194Z","comments":true,"path":"2019/01/24/Remove-Element/","link":"","permalink":"http://yihui37.github.io/2019/01/24/Remove-Element/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行移除元素 - LeetCode 阅读 QuestionGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1:12345Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2:1234567Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification:Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法解法一 72ms我的第一次解题思路：第一次思路与第二十六题思路一样，用双指针快慢的方式，具体代码：12345678910submit(nums) &#123; const len = nums.length; let cur = -1; for(let i = 0;i&lt;nums.length;i++)&#123; if(nums[i]!==val)&#123; nums[cur++]=nums[i]; &#125; &#125; return cur+1;&#125;; 解法二 76ms注意到题干中有提示说The order of elements can be changed，数组中元素顺序可以交换，由此想到另一种思路：当遇到要移除的项时，把它与数组最后一个元素交换位置并释放最后一个元素，这样可以减少赋值操作次数，具体代码：12345678910111213submit(nums,val) &#123; let i = 0; let n = nums.length; while(i&lt;n)&#123; if(nums[i]==val)&#123; nums[i]=nums[n-1]; n--; &#125;else&#123; i++; &#125; &#125; return n; &#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Array","slug":"Array","permalink":"http://yihui37.github.io/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://yihui37.github.io/tags/Two-Pointers/"}]},{"title":"Remove Duplicates from Sorted Array","slug":"Remove-Duplicates-from-Sorted-Array","date":"2019-01-23T03:14:10.000Z","updated":"2019-02-16T06:36:33.049Z","comments":true,"path":"2019/01/23/Remove-Duplicates-from-Sorted-Array/","link":"","permalink":"http://yihui37.github.io/2019/01/23/Remove-Duplicates-from-Sorted-Array/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行删除排序数组中的重复项 - LeetCode 阅读 QuestionGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2:12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification:Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法解法一 96ms我的第一次解题思路：第一次解想了很久没有想出来，后来看了一下题目关联的标签为TwoPointers，由此启发想到使用双指针来解决： 用一个指针来遍历所有元素，另一指针来存储不重复元素（替换原数组）。 后来看到一个更好的表述方式： 使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第一个数字，如果两个指针指的数字相同，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数具体代码：12345678submit(nums) &#123; const len = nums.length; let j = 0; for(let i = 0;i&lt;len;i++)&#123; if(nums[i]!==nums[j]) nums[++j] = nums[i]; &#125; return j+1;&#125;; 可能由于这道题比较简单，大家基本都用的类似解法，没有看到更好的解法。 在这道题中阻挠我的有两处： Given a sorted array nums，题干开头就指明输入值是一个已排序的数组，因此在后续解题过程中可以仅比较不重复数组的最后一个元素与当前元素的大小，而无需考虑当前元素与不重复元素数组中的每一个元素的重复性。 remove the duplicates in-place其中in-place是指原地算法。题干中对此解释为Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory，即只在现有的数组里面进行操作，不在额外的开辟空间。百度中的解释为： 原地算法_百度百科在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部份覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。 因为该方式会覆盖掉原来的输入资料，因此我认为是一个比较危险的方式。而在好的函数语言编译器（compiler）中，该方法被用来最佳化为一个简单的”引擎盖之下”转换。因此此方法的使用需要结合具体场景而定。（个人更趋向于认为这种方法的应用比较少见）。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Array","slug":"Array","permalink":"http://yihui37.github.io/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://yihui37.github.io/tags/Two-Pointers/"}]},{"title":"Merge Two Sorted Lists","slug":"Merge-Two-Sorted-Lists-1","date":"2019-01-22T09:29:49.000Z","updated":"2019-02-26T14:52:11.152Z","comments":true,"path":"2019/01/22/Merge-Two-Sorted-Lists-1/","link":"","permalink":"http://yihui37.github.io/2019/01/22/Merge-Two-Sorted-Lists-1/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example 1:12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Note:1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 解法解法一 88ms我的第一次解题思路：磕磕绊绊bug了好多次。 1.如果l1或l2其一为空，则直接返回另一个。这一点一开始没想到，一直在纠结如何针对空对象做容错处理，没有第一时间反应过来如果其一为空则结果为另一参数 2.整体思路为，将l2中Node拆解出来一个一个和l1中的Node的val比较大小插入到正确的位置 3.容易忽略的点 不要理想化的认为l1就是多节点 不要忘了l2的Node比l1第一个节点小的情况（插入最前面）1234567891011121314151617181920212223242526272829303132333435submit(l1, l2) &#123; if(!l1 || !l2) return l1||l2; while (l2) &#123; let node = &#123; val: l2.val, next: undefined &#125;; l2 = l2.next; insertNode(l1, node); &#125; return l1;&#125;;var insertNode = (list,node)=&gt;&#123; let nextNodeList = list.next; if (node.val &lt; list.val) &#123; // 比当前node小，往前排 const curNode = Object.assign(&#123;&#125;, list); list = Object.assign(list, &#123; val: node.val, next: curNode &#125;); &#125; else if (nextNodeList == undefined) &#123; // 最后一个，直接追加 list.next = Object.assign(node, &#123; next: nextNodeList &#125;); &#125; else if (node.val &gt;= list.val &amp;&amp; node.val &lt; list.next.val) &#123; list.next = Object.assign(node, &#123; next: nextNodeList &#125;); &#125; else &#123; insertNode(nextNodeList, node); &#125;&#125; 解法二 84ms思路为：通过新链表来存储两个链表每次比较的较小Node，具体看代码注释。1234567891011121314151617181920submit(strs) &#123; let preNode = new ListNode(-1), // 新建一个链表 cur = preNode // 指针指向第一个 while(l1 &amp;&amp; l2)&#123; // 两个链表都没有结束 if(l1.val&lt;l2.val)&#123; // 比较两个链表第一个Node值 cur.next = l1 // 较小的那个Node链到新链表里 cur = cur.next // 新链表的指针指向下一个 l1 = l1.next // 链出的链表指针指向下一个 &#125;else&#123; cur.next = l2 cur = cur.next l2 = l2.next &#125; &#125; // 将剩余未链接完毕的nodeList直接链到最后 cur.next = l1 || l2// 注意正确的存储从新链表的第二个Node开始 return preNode.next &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yihui37.github.io/tags/Linked-List/"}]},{"title":"Merge Two Sorted Lists","slug":"Merge-Two-Sorted-Lists","date":"2019-01-22T09:19:57.000Z","updated":"2019-02-16T06:36:44.744Z","comments":true,"path":"2019/01/22/Merge-Two-Sorted-Lists/","link":"","permalink":"http://yihui37.github.io/2019/01/22/Merge-Two-Sorted-Lists/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example 1:12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Note:1234567/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ 解法解法一 88ms我的第一次解题思路：磕磕绊绊bug了好多次。 1.如果l1或l2其一为空，则直接返回另一个。这一点一开始没想到，一直在纠结如何针对空对象做容错处理，没有第一时间反应过来如果其一为空则结果为另一参数 2.整体思路为，将l2中Node拆解出来一个一个和l1中的Node的val比较大小插入到正确的位置 3.容易忽略的点 不要理想化的认为l1就是多节点 不要忘了l2的Node比l1第一个节点小的情况（插入最前面）1234567891011121314151617181920212223242526272829303132333435submit(l1, l2) &#123; if(!l1 || !l2) return l1||l2; while (l2) &#123; let node = &#123; val: l2.val, next: undefined &#125;; l2 = l2.next; insertNode(l1, node); &#125; return l1;&#125;;var insertNode = (list,node)=&gt;&#123; let nextNodeList = list.next; if (node.val &lt; list.val) &#123; // 比当前node小，往前排 const curNode = Object.assign(&#123;&#125;, list); list = Object.assign(list, &#123; val: node.val, next: curNode &#125;); &#125; else if (nextNodeList == undefined) &#123; // 最后一个，直接追加 list.next = Object.assign(node, &#123; next: nextNodeList &#125;); &#125; else if (node.val &gt;= list.val &amp;&amp; node.val &lt; list.next.val) &#123; list.next = Object.assign(node, &#123; next: nextNodeList &#125;); &#125; else &#123; insertNode(nextNodeList, node); &#125;&#125; 解法二 84ms思路为：通过新链表来存储两个链表每次比较的较小Node，具体看代码注释。1234567891011121314151617181920submit(strs) &#123; let preNode = new ListNode(-1) // 新建一个链表 let cur = preNode // 指针指向第一个 while(l1 &amp;&amp; l2)&#123; // 两个链表都没有结束 if(l1.val&lt;l2.val)&#123; // 比较两个链表第一个Node值 cur.next = l1 // 较小的那个Node链到新链表里 cur = cur.next // 新链表的指针指向下一个 l1 = l1.next // 链出的链表指针指向下一个 &#125;else&#123; cur.next = l2 cur = cur.next l2 = l2.next &#125; &#125; // 将剩余未链接完毕的nodeList直接链到最后 cur.next = l1 || l2// 注意正确的存储从新链表的第二个Node开始 return preNode.next &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://yihui37.github.io/tags/Linked-List/"}]},{"title":"Valid Parentheses","slug":"Valid-Parentheses","date":"2019-01-21T07:23:50.000Z","updated":"2019-02-16T06:29:36.487Z","comments":true,"path":"2019/01/21/Valid-Parentheses/","link":"","permalink":"http://yihui37.github.io/2019/01/21/Valid-Parentheses/","excerpt":"","text":"Valid Parentheses 本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行有效的括号 - LeetCode 阅读 QuestionGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.An input string is valid if: 1.Open brackets must be closed by the same type of brackets. 2.Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1:12Input: &quot;()&quot;Output: true Example 2:12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3:12Input: &quot;(]&quot;Output: false Example 4:12Input: &quot;([)]&quot;Output: false Example 5:12Input: &quot;&#123;[]&#125;&quot;Output: true 解法解法一 72ms我的第一次解题思路：将括号匹配信息以对象的键值对形式存储，定义一个顺序空数组，遍历字符串，如果顺序数组中最后一个元素和当前元素是配对的，则抛出最后一个元素，否则向顺序数组中添加当前元素。123456789101112131415161718submit(s) &#123; len = s.length; if(len==0) return true; let match = &#123; '(':')', '&#123;':'&#125;', '[':']' &#125;, order = []; for(let i=0;i&lt;s.length;i++)&#123; if(match[order[order.length-1]]==s[i])&#123; order.pop(); &#125;else&#123; order.push(s[i]); &#125; &#125; return order.length == 0; &#125;; 解法二 68ms思路为：上一解中判断如果为空字符串则直接返回true，想到如果字符串长度为奇数，也可直接返回false。12345678910111213141516171819submit(s) &#123; len = s.length; if(len==0) return true; if(len%2==1) return false; let match = &#123; '(':')', '&#123;':'&#125;', '[':']' &#125;, order = []; for(let i=0;i&lt;s.length;i++)&#123; if(match[order[order.length-1]]==s[i])&#123; order.pop(); &#125;else&#123; order.push(s[i]); &#125; &#125; return order.length == 0; &#125;; 解法三 68ms思路为：前面键值对的匹配是以开端括号作为键名，但如果反过来以闭合括号作为键名，就可以在循环过程中知道是添加还是进行匹配判断，如果错误则不需要循环全部字符。123456789101112131415161718192021submit(s) &#123; len = s.length; if(len ==0) return true; if(len %2==1) return false; var match = &#123; ')':'(', '&#125;':'&#123;', ']':'[' &#125;, order = []; for(let i=0;i&lt;s.length;i++)&#123; var matchItem = match[s[i]]; if(matchItem)&#123; if(order[order.length-1]!==matchItem) return false; order.pop(); &#125;else&#123; order.push(s[i]); &#125; &#125; return order.length == 0;&#125; 该方法应该比前两种更快，不知道为啥测出来时间没有减少=-=。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"String","slug":"String","permalink":"http://yihui37.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"http://yihui37.github.io/tags/Stack/"}]},{"title":"Longest Common Prefix","slug":"Longest-Common-Prefix","date":"2019-01-18T08:33:39.000Z","updated":"2019-02-16T06:31:24.909Z","comments":true,"path":"2019/01/18/Longest-Common-Prefix/","link":"","permalink":"http://yihui37.github.io/2019/01/18/Longest-Common-Prefix/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行最长公共前缀 - LeetCode 阅读 QuestionWrite a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”. Example 1:12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2:123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note:All given inputs are in lowercase letters a-z. 解法解法一 76ms我的第一次解题思路：取数组中最后一个元素来遍历每一个字符，用正则校验剩余数组中每一个元素是否以此开头，是则保存这个字符并继续，否则退出当前存储字符串，最终结果由0到all。123456789101112submit(strs) &#123; if(!strs.length) return \"\"; let last = strs.pop().split(\"\"), prefix = \"\"; for (let i = 0; i &lt; last.length; i++) &#123; let reg = new RegExp('^'+ prefix + last[i]); let flag = strs.find(item =&gt; !reg.test(item)); if (flag !== undefined) return prefix; prefix += last[i]; &#125; return prefix; &#125;; 解法二 72ms思路为：使用.startsWith(String prefix, int toffset)方法代替正则匹配，使用第一个元素作为校验值，不匹配则依次去掉元素的最后一个字符继续匹配，直到匹配到全部符合的prefix，最终结果由all到0。12345678910submit(strs) &#123; if (strs.length == 0) return \"\"; let prefix = strs[0]; for(let i=0 ; i &lt; strs.length; i++)&#123; while(! strs[i].startsWith(prefix) )&#123; prefix = prefix.substring(0, prefix.length-1); &#125; &#125; return prefix &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"String","slug":"String","permalink":"http://yihui37.github.io/tags/String/"}]},{"title":"Palindrome Number","slug":"Palindrome-Number","date":"2019-01-16T13:05:23.000Z","updated":"2019-02-16T06:31:41.062Z","comments":true,"path":"2019/01/16/Palindrome-Number/","link":"","permalink":"http://yihui37.github.io/2019/01/16/Palindrome-Number/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行 QuestionDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1:12Input: 121Output: true Example 2:123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up:Coud you solve it without converting the integer to a string? 解法解法一该题目是上一篇Reverse Integer的同类题，我的第一次解题思路，仍然是使用Array.reverse()方法，因此有了Number-&gt;String-&gt;Array-&gt;Array.reverse()-&gt;String-&gt;Number的思路。1234submit(x) &#123; let r = x.toString().split(\"\").reverse().join(\"\"); return r===x.toString();&#125; 提交后发现耗费了288ms，超越了22.1% 。 解法二依据题干提示不要转换为String类型来解答，正好上一篇的Reverse Integer第二种解法符合条件，即依照个十百位依次取值的方式完成倒序，具体如下。1234567891011121314submit(array, target) &#123; let xReverse = 0, xOrg = x; if (xOrg &lt; 0) &#123; return false; &#125; while (x) &#123; xReverse = xReverse * 10 + x % 10; x = Math.floor(x/10); &#125; if (xReverse === xOrg) &#123; return true; &#125; return false;&#125; 这次提交后检测耗费260ms，超越了44.21%","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Math","slug":"Math","permalink":"http://yihui37.github.io/tags/Math/"}]},{"title":"Reverse Integer","slug":"Reverse-Integer","date":"2019-01-15T03:21:44.000Z","updated":"2019-02-16T06:30:50.058Z","comments":true,"path":"2019/01/15/Reverse-Integer/","link":"","permalink":"http://yihui37.github.io/2019/01/15/Reverse-Integer/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在 这里 找到我的项目代码实际运行反转整数 - LeetCode 阅读 QuestionGiven a 32-bit signed integer, reverse digits of an integer. Example 1:12Input: 123Output: 321 Example 2:12Input: -123Output: -321 Example 3:12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解法解法一我的第一次解题思路，第一反应是数组有一个倒序的方法，即Array.reverse()，因此有了Number-&gt;String-&gt;Array-&gt;Array.reverse()-&gt;String-&gt;Number的思路。1234567submit(x) &#123; let sign = x &gt; 0 ? 1 : -1; // 正负号 let num = Math.abs(x); // 绝对值 let reverse = Number(num.toString().split('').reverse().join('')) * sign; // 倒序转换 if(reverse&gt;Math.pow(2,31)-1 || reverse &lt; Math.pow(-2,31)) reverse = 0; // 判断32位数值区间 return reverse;&#125; 提交后发现耗费了96ms，超越了31.72% 。 解法二后来想到会不会是因为转换太多了比较消耗性能，于是尝试了一下使用全Number，依照个十百位依次取值的方式，具体如下。1234567891011submit(array, target) &#123; let reverse = 0; while (x) &#123; reverse = reverse*10 + x % 10; x = parseInt(x/10); &#125; if (reverse &gt; Math.pow(2, 31) - 1 || reverse &lt; Math.pow(-2, 31)) &#123; return 0; &#125; return reverse;&#125; 这次提交后检测耗费92ms，超越了35.76% 由此怀疑LeetCode的测速是不是有其他因素影响，去搜了一下发现这个测速不准，同样的代码可能会测出差别较大的结果，因此我又去LeetCode上的Submissions中查看了耗时最少68ms的解答，发现测试出来还是92ms。 Emmmmm，后续应该不会追求这个百分比了。ㄟ( ▔, ▔ )ㄏ","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Math","slug":"Math","permalink":"http://yihui37.github.io/tags/Math/"}]},{"title":"Two Sum","slug":"Two-Sum","date":"2019-01-14T13:39:35.000Z","updated":"2019-02-16T06:29:51.599Z","comments":true,"path":"2019/01/14/Two-Sum/","link":"","permalink":"http://yihui37.github.io/2019/01/14/Two-Sum/","excerpt":"","text":"本文为LeetCode刷题系列笔记，你可以在这里找到我的项目代码实际运行 QuestionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解法解法一我的第一次解题思路，使用嵌套的for循环来试两个数组元素相加并与target进行比较，相等则退出循环，并返回元素序列数组。123456789submit(array, target) &#123; let hash = &#123;&#125;; for (let [findex, i] of nums.entries()) &#123; if (hash[target - i] !== undefined) &#123; return [hash[target - i], findex]; &#125; hash[i] = findex; &#125;&#125; 提交后发现耗费了1025ms，仅超越了2.5% 的提交记录，大受打击&gt;.&lt; 原来自己的方法是非常落后的。 解法二后来在左侧的问题标签中发现有hash的标签，因此有了思路：将数组元素与其序列存在一个对象中，用查找对象的方式来判断符合条件，具体如下。123456789submit(array, target) &#123; let hash = &#123;&#125;; for (let [index, value] of nums.entries()) &#123; if (hash[target - value] !== undefined) &#123; return [hash[target - value], index]; &#125; hash[value] = index; &#125;&#125; 这次提交后检测耗费80ms，超越了59.88%，意味着还有更优的解法。 解法三解法二中使用ES6数组的扩展.entries()来遍历数组，之前没有比较过和for循环的性能，这次改为for循环试一下。123456789submit(array, target) &#123; let hash = &#123;&#125;; for (let i = 0; i &lt; nums.length; i++) &#123; if (hash[target - nums[i]] !== undefined) &#123; return [hash[target - nums[i]], i]; &#125; hash[nums[i]] = i; &#125;&#125; 这次提交检测耗费72ms，超越了69.95% ，还不是最优解。 但是自己完全没有头绪了，因此到LeetCode上看了Discuss，发现有许多标题100%的解法与方法二三的思路是一样的，只是写法不太一样，而且复制提交测试后依然是72ms,并没有任何提升，不知道是什么原因=-=。 后续有好的方法再贴吧~","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yihui37.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode/easy","slug":"LeetCode-easy","permalink":"http://yihui37.github.io/tags/LeetCode-easy/"},{"name":"每天进步一点点","slug":"每天进步一点点","permalink":"http://yihui37.github.io/tags/每天进步一点点/"},{"name":"Array","slug":"Array","permalink":"http://yihui37.github.io/tags/Array/"},{"name":"Hash","slug":"Hash","permalink":"http://yihui37.github.io/tags/Hash/"}]},{"title":"Fullstack lesson2","slug":"Fullstack-lesson2","date":"2019-01-13T12:10:07.000Z","updated":"2019-01-13T12:21:10.630Z","comments":true,"path":"2019/01/13/Fullstack-lesson2/","link":"","permalink":"http://yihui37.github.io/2019/01/13/Fullstack-lesson2/","excerpt":"","text":"本文为自己学习笔记，而不是一篇教程，仅供自己日后回顾使用但若其中某tip能为你提供些许帮助，你可以在心里为我撒个花花🌹(^__^) 自己写一个el-form参照element-ui自己尝试模拟写了一个el-form的公共组件，实现登录验证功能： input失去焦点时进行单个验证 点击登录按钮时整体表单验证 验证使用async-validate插件完成 组件层级本次登录组件主要由三个组件组成 Form - 最外层表单 FormItem - 表单项 Input - 表单数据输入，可以由不同其他DOM代替三者关系如图TODO 图Slot组件间由slot插槽进行相互关联，因此不可用@event来绑定监听事件，即插槽内的子组件不可用直接用$emit来触发父组件事件。解决方式 this.$parent.$emit存在问题：如果用户不按照既定层级编写组件，则会存在this.$parent不是我们要找的FormItem的问题 commonVue绑定（不推荐）需要自己实例化一个外部VUE，并引入，并且事件的绑定和触发来源会难以追溯Provide&amp;Inject 官方说明注意：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。我们在Form层级将表单父级使用provide抛出，在FormItem层级通过Inject将父级依赖注入，这样不论FormItem是多少层级的组件，都可以直接获得最外父级的属性和方法。 1234567891011121314&#123;name: \"my-form\", provide() &#123; return &#123; // 将表单实例传递给后代 form: this &#125;; &#125;&#125;&#123; name: \"my-form-item\", inject: [\"form\"], // 注入form，获取model和rules&#125; 这样，在FormItem进行验证的时候，就可以使用用户绑定在Form中的验证项和验证规则 Input的事件作为表单输入框，input主要承担数据的输入工作，一方面它接受父组件传入的参数作为默认值，另一方面在用户改变输入值的同时触发校验 单向数据流 根据VUE的单向数据流规则，从props获取到的数据，子组件是不允许修改的，因此input在用户改变输入之后的处理回调里，需要通知父组件进行数据更新 触发校验 input的校验通常有@blur和@input两种，可以在组件上新增一个trigger属性，用户就可以自己选择触发方式 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;input :type=\"type\" :value=\"inputValue\" @blur=\"validate\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"my-input\", props: &#123; value: &#123; type: String, default: \"\" &#125;, type: &#123; type: String, default: \"text\" &#125; &#125;, data() &#123; return &#123; inputValue: this.value // 单向数据流,接受父组件传过来的默认值 &#125;; &#125;, methods: &#123; validate(e) &#123; this.inputValue = e.target.value; // 必要，通知父组件更新 this.$emit(\"input\", this.inputValue); // 通知父组件校验 // tip: 不自己校验是因为 // form整体校验的时候，并不一定就是input，还可能会是复杂组件 // 因此在formitem层级进行校验 // 方法一：错误 // this.$emit(\"validate\", this.inputValue); // 因为input以插槽的形式插入formitem中，并不能直接$emit // 方法二：当用户不按既定层级编写代码时，$parent不是formitem,因此不完善 this.$parent.$emit(\"validate\", this.inputValue); &#125; &#125;&#125;; Async-validate单个表单的校验async-validate12345678910111213141516171819202122232425262728293031// 验证单个formitem validate() &#123; // promise作用为 在整体校验时提供状态 return new Promise(res =&gt; &#123; // 校验规则 const descriptor = &#123; // 此处this.form为父组件provider提供 [this.prop]: this.form.rules[this.prop] &#125;; const validator = new schema(descriptor); // 执行校验 // 校验参数 param // &#123; prop : propValue&#125; propValue由父组件的provider this.form.model[this.prop] &#125;); validator.validate( &#123; [this.prop]: this.form.model[this.prop] &#125;, errors =&gt; &#123; if (errors) &#123; this.isError = true; this.errormsg = errors[0].message; res(false); &#125; else &#123; this.isError = false; this.errormsg = \"\"; res(true); &#125; &#125; ); &#125;); &#125; TIPS: 别忘了引入async-validate Validate以promise返回，供表单整体校验时提供异步等待机制整体校验 缓存需要校验的表单项，有些没有prop的不需要校验 使用async await和Promise.all进行整体校验判断1234567891011121314151617&#123; created() &#123; // 缓存需要校验的表单项 this.fields = []; this.$on(\"formItemAdd\", item =&gt; this.fields.push(item)); &#125;, methods: &#123; // 回调 // 验证所有formitem async validate(callback) &#123; const tasks = this.fields.map(item =&gt; item.validate()); const results = await Promise.all(tasks); let flag = results.filter(valid =&gt; valid == false).length == 0; callback(flag); &#125; &#125;&#125; 自定义组件命名注意：自定义组件name属性不要和已安装的UI组件的标签名称一致，渲染时会报堆栈溢出，找了半天bug😭。123export default &#123; name: “el-form” // 不要取element-ui一样的名称 &#125;","categories":[{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/categories/Fullstack/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/tags/Fullstack/"}]},{"title":"Fullstack lesson1","slug":"Fullstack-lesson1","date":"2019-01-08T14:58:51.000Z","updated":"2019-01-13T12:21:20.183Z","comments":true,"path":"2019/01/08/Fullstack-lesson1/","link":"","permalink":"http://yihui37.github.io/2019/01/08/Fullstack-lesson1/","excerpt":"","text":"本文为自己学习笔记，而不是一篇教程，仅供自己日后回顾使用但若其中某tip能为你提供些许帮助，你可以在心里为我撒个花花🌹(^__^) VUE-CLI 3与VUE-CLI 2 的区别 npm安装依赖名称变更 @vue/cli CLI2中的cofig文件夹取消，变更为使用在根目录下创建vue.config.js文件来进行配置 CLI3实例化方式有区别，如下： 1234567891011// CLI2new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;)// CLI3new Vue(&#123; render: h =&gt; h(App), // 渲染App组件供$mount挂载&#125;).$mount('#app') // 将render出的App组件挂载到DOM#app上 快速原型开发 运行单个.vue文件 123npm install -g @vue/cli-service-globalcd &lt;filepath&gt;vue serve &lt;filename&gt; 单个.vue文件中 data必须以function形式返回，而在组件形式的.vue文件中，则以对象形式返回 快速创建项目在package.json文件中，配置start和dev/build等，在执行时start不需要加run 1234npm startnpm run devnpm run build... Mock数据 项目根目录下配置vue.config.js文件，创建一个自定义的接口返回 安装axios依赖 注意重启项目 如使用ES7的async await来处理异步，则注意错误处理使用try catch","categories":[{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/categories/Fullstack/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Fullstack","slug":"Fullstack","permalink":"http://yihui37.github.io/tags/Fullstack/"}]},{"title":"Element-UI 自定义参数传递","slug":"Element-UI组件回调自定义传参","date":"2018-07-26T08:46:26.000Z","updated":"2019-01-13T12:12:22.143Z","comments":true,"path":"2018/07/26/Element-UI组件回调自定义传参/","link":"","permalink":"http://yihui37.github.io/2018/07/26/Element-UI组件回调自定义传参/","excerpt":"","text":"本文主要讲述Element-UI中组件事件回调如何在保留默认传参的情况下，额外传递自定义参数。 Element-UI框架中的组件事件回调传参一般只有v-model的绑定值，然而在实际开发过程中，经常会遇到既需要绑定值，也需要其他参数（尤以循环数组需要当前对象和index居多）的情况。在项目搭建伊始，这个问题就在困扰着我，当时的解决方法尤其笨拙： 在绑定组件上添加click事件，将自定义参数通过click事件绑定到全局变量中，之后通过全局变量来确定当前变更元素。此方法一是需要确保click事件比组件的change事件优先执行；二是新增了变量就意味着占据内存来存储一个既有值；三是一不小心就会忘了当前存储值是什么，需要不断log调试 这个笨拙的方法虽然解决了问题，却有一种问我9✖️9等于多少，我只能用9+9+9+9+9+9+9+9+9=81累加方法算出答案，一直觉得麻烦，却不知道好方法的感觉。 当然，如今我终于习得99乘法表。 使用闭包重新包装回调函数 @change=&quot;selectValue=&gt;handleChange(selectValue,index)&quot;此方法简单高效，直接解决了困扰已久的问题，激动无以言表 实例有一组数据selectedRepos，其中每个元素都需要通过远程搜索获取到可选列表再进行选择，同时将搜索结果作为属性值保存在当前元素中。123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;repoWrap&quot; v-for=&quot;(repo,index) of selectedRepos&quot; :key=&quot;index&quot;&gt; &lt;el-select :ref=&quot;`repoSelect$&#123;index&#125;`&quot; v-model=&quot;repo.id&quot; remote // 远程搜索，既需要查询条件query，也需要当前数组元素repo :remote-method=&quot;query=&gt;remoteSearch(query,repo)&quot; @change=&quot;selectRepo(repo)&quot; :loading=&quot;remote_loading&quot; value-key=&quot;repo_info.id&quot;&gt; &lt;el-option v-for=&quot;repo in repo.repoOptions&quot; :key=&quot;repo.id&quot; :label=&quot;repo.repo_name&quot; :value=&quot;repo&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; methods:&#123; remoteSearch(query,repo)&#123; ... &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yihui37.github.io/tags/Javascript/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"}]},{"title":"Element Dialog append-to-body","slug":"el-dialog关闭","date":"2018-07-16T07:13:29.000Z","updated":"2018-07-26T08:47:06.000Z","comments":true,"path":"2018/07/16/el-dialog关闭/","link":"","permalink":"http://yihui37.github.io/2018/07/16/el-dialog关闭/","excerpt":"","text":"Element Dialog 无法关闭 本文主要介绍Element-UI(VUE)·Dialog的append-to-body属性 你是否在使用Dialog的过程中，遇到过不能关闭或Dialog Events无效，却不知道如何解决？ 现在让我们一起来看看append-to-body能不能帮助你解决这个问题吧。 Dialog 官方文档 $ Attributes 在实际开发过程中，虽然在单个组件中只有一个Dialog，但实际页面中，由于父子组件间的多层嵌套，Dialog也具有了嵌套的关系，从而导致内外Dialog的遮罩层级关系出错、无法捕捉关闭事件等一系列问题。因此，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 实例 父组件 1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\"&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; 子组件 serviceDetail 12345methods: &#123; handleDeploy() &#123; commonVue.$emit('openServiceDeploy'); // 打开公共组件 &#125;&#125; 公共组件 rightContainer 123456&lt;!-- 子组件中的Dialog 第二层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"rightContainer-dialog\" :visible.sync=\"visible\"&gt; ... &lt;/el-dialog&gt;&lt;/template&gt; 问题：在上例中，父组件有一个Dialog，其中嵌套了子组件serviceDetail，在serviceDetail组件中，调用了公共方法打开公共组件Dialog。此时，页面上共存两个dialog，但是父组件中的Dialog（页面视觉上在下面一层）无法关闭。解决方法：在父组件的Dialog上添加append-to-body属性，重组层级关系。1234567&lt;!-- 父组件中的Dialog 第一层级 --&gt;&lt;template&gt; &lt;el-dialog id=\"serviceDetailDialog\" :visible.sync=\"dialogVisible\" append-to-body&gt; &lt;!-- 子组件 --&gt; &lt;serviceDetail&gt;&lt;/serviceDetail&gt; &lt;/el-dialog&gt;&lt;/template&gt; TIP：在开发过程中，很可能因为子组件中没有直接写Dialog代码，而忽略了公共组件中Dialog的嵌套问题，建议在每个Dialog组件都加上append-to-body属性来避免这一问题。 PS：无脑添加append-to-body属性是否会带来性能方面的影响暂未研究。如有此方面研究，请不吝赐教。","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Dialog","slug":"Dialog","permalink":"http://yihui37.github.io/tags/Dialog/"}]},{"title":"Element select value-key","slug":"el-select绑定值为对象类型","date":"2018-07-11T07:13:29.000Z","updated":"2018-07-26T08:47:13.000Z","comments":true,"path":"2018/07/11/el-select绑定值为对象类型/","link":"","permalink":"http://yihui37.github.io/2018/07/11/el-select绑定值为对象类型/","excerpt":"","text":"Element-UI Select 绑定值为Object对象类型 本文主要介绍Element-UI(VUE)·Select的value-key属性 在使用Element1.0的开发过程中，option的value只能绑定字符串或数字，常常在选择之后再实时根据v-model绑定的值进行数据的筛选，从而获取到object中其它需要的属性数据； 现在Select对value新增了object数据类型的支持，我们来看看要怎么使用吧。 Select 官方文档 $ Select Attributes Option Attributes 由此可以看出，当value绑定值类型为object时，value-key为必填项，其值为对象的某个key[字符串类型] 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;el-select v-model=&quot;selectItems&quot; // Array multiple // 多选 value-key=&quot;id&quot; // 指定object的唯一标识（id是item的一个key） @change=&quot;handleChange&quot;&gt; &lt;el-option v-for=&quot;item in options&quot; :key=&quot;item.id&quot; // v-for 的 key :label=&quot;item.title&quot; :value=&quot;item&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; options: [&#123; id:1, value: &apos;选项1&apos;, title: &apos;黄金糕&apos; &#125;, &#123; id:2, value: &apos;选项2&apos;, title: &apos;双皮奶&apos; &#125;, &#123; id:3, value: &apos;选项3&apos;, title: &apos;蚵仔煎&apos; &#125;, &#123; id:4, value: &apos;选项4&apos;, title: &apos;龙须面&apos; &#125;], selectItems: [], &#125; &#125;, methods:&#123; handleChange(selectItems)&#123; console.log(&apos;选中值&apos;,selectItems); // 选中值 [object,object] &#125; &#125; &#125;&lt;/script&gt; TIPS 注意区分select的value-key和option的key 前者作为select的属性，是value值的唯一标识后者是使用v-for时，给每个节点做一个唯一标识，此时key的作用主要是为了高效的更新虚拟DOM","categories":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/categories/Element-UI/"}],"tags":[{"name":"Element-UI","slug":"Element-UI","permalink":"http://yihui37.github.io/tags/Element-UI/"},{"name":"VUE","slug":"VUE","permalink":"http://yihui37.github.io/tags/VUE/"},{"name":"Select","slug":"Select","permalink":"http://yihui37.github.io/tags/Select/"}]},{"title":"css-border滑动动画","slug":"css-border滑动动画","date":"2018-02-27T07:49:51.000Z","updated":"2019-01-13T12:13:35.079Z","comments":true,"path":"2018/02/27/css-border滑动动画/","link":"","permalink":"http://yihui37.github.io/2018/02/27/css-border滑动动画/","excerpt":"","text":"本文主要使用css-transition属性来实现元素边框的流动动画效果 序无意中发现个人主页插件演示页面，在个人履历中看到了边框滑动效果，研究了一下发现是由纯css完成的，由此记录学习一下。在之前学习svg的过程中，实现过不规则图形的边框滑动效果，由于实现方式比较复杂，所以很少在实际项目中使用。 效果展示移动鼠标到这里查看效果~ 原理分析调试分析后发现实际是使用两个同样大小的内外盒子，使用伪类元素::before ::after来模拟边框。一个盒子负责上下边框，另一个负责左右边框。由起点框开始变化，变化结束后，另一个盒子再承接上一个结束点进行变化，由此在视觉上看起来等同于一个盒子的边框动画。 实现代码12345678&lt;!--html--&gt;&lt;div class=\"border-slide-wrapper\"&gt; &lt;div class=\"outwrap\"&gt; &lt;div class=\"innerwrap\"&gt; &lt;h3&gt;移动鼠标到这里查看效果~&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*stylus*/.border-slide-wrapper text-align center margin 15px .outwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 0px height 2px background #FF9D9B transition .2s all linear // 无延迟 &amp;::before top 0px left 0px &amp;::after bottom 0px right 0px &amp;:hover::before,&amp;:hover::after width 100% .innerwrap position relative &amp;::before,&amp;::after content '' display block position absolute width 2px height 0px background #FF9D9B transition .2s all linear .2s // 延迟.2s，等待前置滑动结束 &amp;::before bottom 0px left 0px &amp;::after top 0px right 0px &amp;:hover::before,&amp;:hover::after height 100% h3 padding 20px color #FF7C79","categories":[{"name":"CSS奇幻世界","slug":"CSS奇幻世界","permalink":"http://yihui37.github.io/categories/CSS奇幻世界/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yihui37.github.io/tags/CSS/"}]},{"title":"Markdown简介","slug":"欢迎使用马克飞象","date":"2018-01-12T03:53:59.000Z","updated":"2019-01-13T12:13:10.817Z","comments":true,"path":"2018/01/12/欢迎使用马克飞象/","link":"","permalink":"http://yihui37.github.io/2018/01/12/欢迎使用马克飞象/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#117;&#115;&#116;&#x67;&#111;&#99;&#x6b;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yihui37.github.io/tags/Markdown/"}]}]}